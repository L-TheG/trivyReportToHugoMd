import { readFile } from "fs/promises";
import fs from "fs";
import * as path from "path";
const outDir = "./src/data/out";

/*
The json structure, generated by the trivy report can be found at the bottom of this file:
*/
await main();

async function main() {
  const trivyJsonReport = JSON.parse(await readFile("./src/data/report.json"));

  const vulnerabilities = extractVulnerabilities(trivyJsonReport);
  const misconfigurations = extractMisconfigurations(trivyJsonReport);

  await createVulnerabilityFiles(vulnerabilities);
  await createMisconfigurationFiles(misconfigurations);

  await createIndexFiles();
}

function extractMisconfigurations(trivyJsonReport) {
  const reportEntries = trivyJsonReport.Misconfigurations;

  // remove all entries that have no results
  let targetableComponents = reportEntries.filter((entry) =>
    entry.hasOwnProperty("Results")
  );

  // Split every result into its own object
  // merge that with parent object
  let flattenedTargets = mergeChildrenWithParentObjs(
    targetableComponents,
    "Results"
  );

  // remove all targets without vulnerabilities
  let misconfiguredComponents = flattenedTargets.filter((target) =>
    target.hasOwnProperty("Misconfigurations")
  );

  // Split every vulnerability into its own object
  // merge that with parent object
  let misconfigurations = mergeChildrenWithParentObjs(
    misconfiguredComponents,
    "Misconfigurations"
  );

  return misconfigurations;
}

function extractVulnerabilities(trivyJsonReport) {
  const reportEntries = trivyJsonReport.Vulnerabilities;

  // remove all entries that have no results
  let targetableComponents = reportEntries.filter((entry) =>
    entry.hasOwnProperty("Results")
  );

  let flattenedTargets = mergeChildrenWithParentObjs(
    targetableComponents,
    "Results"
  );

  // remove all targets without vulnerabilities
  let vulnerableComponents = flattenedTargets.filter((target) =>
    target.hasOwnProperty("Vulnerabilities")
  );

  let vulnerabilities = mergeChildrenWithParentObjs(
    vulnerableComponents,
    "Vulnerabilities"
  );

  return vulnerabilities;
}

async function createMisconfigurationFiles(misconfigurations) {
  const misconfigurationMarkdownTemplate = (
    await readFile("./src/data/misconfTemplate.txt")
  ).toString();

  misconfigurations.forEach((misconf, index) => {
    let markdown = buildMisconfMarkdown(
      misconfigurationMarkdownTemplate,
      misconf
    );

    let dir =
      outDir +
      "/" +
      "Misconfigurations" +
      "/" +
      misconf.Severity +
      "/" +
      misconf.Namespace;
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(dir + "/" + misconf.AVDID + "-" + index + ".md", markdown);
  });
}

function buildMisconfMarkdown(template, misconf) {
  for (const [key, value] of Object.entries(misconf)) {
    const replaceString = reformatString(key);
    const regexp = new RegExp(`${replaceString}`, "gi");

    // convert part that points to specific code, to markdown code block
    if (key === "CauseMetadata") {
      const codeData = buildMisconfCodeBlock(value);
      template = template.replace("_codeBlock", codeData.code);
      template = template.replace("_firstLineNumber", codeData.startLine);
      const highlightLineString = codeData.linesToHighlight
        .toString()
        .replace(new RegExp(",", "gi"), " ");
      template = template.replace("_linesToHighlight", highlightLineString);
    }

    // create expandable markdown list element
    if (Array.isArray(value)) {
      let arrayString = '{{%expand "' + key + '" %}}\n\n';
      value.forEach((element) => {
        arrayString = arrayString + "- " + element + "\n";
      });
      arrayString = arrayString + "{{% /expand%}}\n";
      template = template.replace(regexp, arrayString);

      // simply exchange template with object value
    } else {
      let stringToReplace = sanitiseStringForMarkdown(value);
      template = template.replace(regexp, stringToReplace);
    }
  }
  return template;
}

function buildMisconfCodeBlock(misconfData) {
  const startLine = misconfData.StartLine;
  const linesToHighlight = [];
  let code = "";
  misconfData.Code.Lines.forEach((line, index) => {
    code = code + line.Content + "\n";
    if (line.IsCause) linesToHighlight.push(index);
  });

  return {
    code: code,
    linesToHighlight: linesToHighlight,
    startLine: startLine,
  };
}

async function createVulnerabilityFiles(vulnerabilities) {
  const vulnerabilityMarkdownTemplate = (
    await readFile("./src/data/vulnTemplate.txt")
  ).toString();

  vulnerabilities.forEach((vuln) => {
    let markdown = buildVulnMarkdown(vulnerabilityMarkdownTemplate, vuln);

    // create directory
    let dir =
      outDir +
      "/" +
      "Vulnerabilities" +
      "/" +
      vuln.Severity +
      "/" +
      vuln.Namespace;
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(dir + "/" + vuln.VulnerabilityID + ".md", markdown);
  });
}

// Every part that is to be replaced has _+first char as lowercase in the template
// ex: JSON Field Class is represented by _class in the template. _class will be replaced by the value of the Class field in the JSON object
function buildVulnMarkdown(template, vulnerabilitiy) {
  for (const [key, value] of Object.entries(vulnerabilitiy)) {
    const replaceString = reformatString(key);
    const regexp = new RegExp(`${replaceString}`, "gi");

    // convert object into json format
    if (typeof value === "object" && !Array.isArray(value)) {
      let objString = JSON.stringify(value, null, 2);
      template = template.replace(regexp, objString);
    }

    // create expandable markdown list element
    if (Array.isArray(value)) {
      let arrayString = '{{%expand "' + key + '" %}}\n\n';
      value.forEach((element) => {
        arrayString = arrayString + "- " + element + "\n";
      });
      arrayString = arrayString + "{{% /expand%}}\n";
      template = template.replace(regexp, arrayString);

      // simply exchange template with object value
    } else {
      let stringToReplace = sanitiseStringForMarkdown(value);

      template = template.replace(regexp, stringToReplace);
    }
  }

  return template;
}

// Each directory needs its own index file
async function createIndexFiles() {
  const dirs = getDirectoriesRecursive(outDir);
  const indexTemplate = (
    await readFile("./src/data/dirIndexTemplate.txt")
  ).toString();

  dirs.forEach((dir) => {
    const pathElements = dir.split(path.sep);
    const title = pathElements[pathElements.length - 1];
    // Top level index file has special title
    if (title.includes("out")) {
      fs.writeFileSync(
        dir + "/" + "_index.md",
        indexTemplate.replace("_title", "Vulnerability Scan")
      );
    } else {
      fs.writeFileSync(
        dir + "/" + "_index.md",
        indexTemplate.replace("_title", title)
      );
    }
  });
}

// makes first chat lowercase and prefixes _ to the string
function reformatString(value) {
  return "_" + value.slice(0, 1).toLocaleLowerCase() + value.slice(1);
}

function getDirectoriesRecursive(srcpath) {
  return [
    srcpath,
    ...flatten(getDirectories(srcpath).map(getDirectoriesRecursive)),
  ];
}

function flatten(lists) {
  return lists.reduce((a, b) => a.concat(b), []);
}

function getDirectories(srcpath) {
  return fs
    .readdirSync(srcpath)
    .map((file) => path.join(srcpath, file))
    .filter((path) => fs.statSync(path).isDirectory());
}

function sanitiseStringForMarkdown(value) {
  let result = value.toString().replace(new RegExp(/\\/g), "\\\\");
  result = result.replace(/"/g, '\\"');
  result = result.replace(/\n/g, "");
  return result;
}

// Split every _childObj_ into its own component
// add all its parents properties to it
function mergeChildrenWithParentObjs(listOfObjects, childObjName) {
  let returnObject = [];
  listOfObjects.forEach((currentObj) => {
    currentObj[childObjName].forEach((element) => {
      let finalEntry = Object.assign({}, element, currentObj);
      delete finalEntry[childObjName];
      returnObject.push(finalEntry);
    });
  });
  return returnObject;
}

/*
{
  "ClusterName": "string",
  "Misconfigurations": [
    {
      "Kind": "string",
      "Namespace": "string",
      "Name": "string",
      "Results": [
        {
          "Class": "string",
          "Target": "string",
          "Type": "string",
          "MisconfSummary": {
            "Successes": "integer",
            "Failures": "integer",
            "Exceptions": "integer"
          },
          "Misconfigurations": [
            {
              "Type": "string",
              "ID": "string",
              "AVDID": "string",
              "Title": "string",
              "Description": "string",
              "Message": "string",
              "Namespace": "string",
              "Query": "string",
              "Resolution": "string",
              "Severity": "string",
              "PrimaryURL": "string",
              "References": [
                "string"
              ],
              "Status": "string",
              "CauseMetadata": {
                "Provider": "string",
                "Service": "string",
                "StartLine": "integer",
                "EndLine": "integer",
                "Code": {
                  "Lines": [
                    {
                      "Number": "integer",
                      "Content": "string",
                      "IsCause": "boolean",
                      "Annotation": "string",
                      "Truncated": "boolean",
                      "FirstCause": "boolean",
                      "LastCause": "boolean"
                    }
                  ]
                }
              }
            }
          ]
        }
      ]
    }
  ],
  "Vulnerabilities": [
    {
      "Kind": "string",
      "Namespace": "string",
      "Name": "string",
      "Results": [
        {
          "Class": "string",
          "Target": "string",
          "Type": "string",
          "Vulnerabilities": [
            {
              "VulnerabilityID": "string",
              "VendorIDs": [
                "string"
              ],
              "PkgName": "string",
              "InstalledVersion": "string",
              "FixedVersion": "string",
              "Layer": {
                "Digest": "string",
                "DiffID": "string"
              },
              "DataSource": {
                "ID": "string",
                "Name": "string",
                "URL": "string"
              },
              "Title": "string",
              "Severity": "string"
            }
          ]
        }
      ]
    }
  ]
}
*/
